<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to osmprob • osmprob</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/readable/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">osmprob</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Vignette</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/osm-router/osmprob">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Introduction to osmprob</h1>
                        <h4 class="author">Andreas Petutschnig</h4>
            
            <h4 class="date">2017-06-05</h4>
          </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      When using routing algorithms to model movement on a graph, one is not necessarily interested in obtaining the least-cost, but the most realistic results. The average path between any two points is likely never the shortest, yet there is currently no way to estimate the course or lengths of realistic paths. Instead, movement is often assumed to be singular and repeatable. <strong>osmprob</strong> is an <em>R</em> library that provides routing probabilities along all possible paths between any two points. The path of highest probability is the shortest, yet all edges will generally have non-zero probabilities of being traversed. Importantly, the resultant network enables calculation of the probabalistically most likely distance travelled between any two points. The package comes with a built-in <strong>Shiny</strong> <strong>Leaflet</strong> application to display the results in a matter that is both understandable and visually pleasing.
    </div>
    
<div class="contents">
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p><code>osmprob</code> is an <em>R</em> package that allows users to calculate traversal probabilities and the estimated travel distance between two points on a graph based on the methods introduced in <span class="citation">Saerens et al. (<a href="#ref-saerens2009randomized">2009</a>)</span>. It is intended to serve as a tool for researchers in fields related to city planning, logistics or transportation in general. With it, they can estimate realistic travelling distances and patterns by simply executing a few lines of code. The package also contains methods that simplify the process of downloading and preprocessing road data on which the routing can be performed. This step also includes weighting the edges according to a specified means of transport. The values used for weighting are derived from the Routino weighting profiles<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, but can also be adjusted manually. Finally, the results can either be visualised with built-in mapping functions or used for further analysis.</p>
<div id="r-packages" class="section level2">
<h2 class="hasAnchor">
<a href="#r-packages" class="anchor"></a><em>R</em> packages</h2>
<p><em>R</em> is a programming language that is maintained by the <em>R</em> Foundation for Statistical Computing<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> and is freely available under the GNU General Public License. <em>R</em> uses the concept of packages, which allow users to access additional functionality from external sources. These packages are written and maintained by numerous contributors and can be accessed via the Comprehensive R Archive Network (CRAN)<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. The packages are built according to a specific structure, which is explained in <span class="citation">Wickham (<a href="#ref-wickham2015r">2015</a>)</span>, which leads to high interoperability of the contributed software. This software was also built in form of a package. One reason why this format was chosen was because of its interoperability. <em>R</em> is platform independent an can therefore be used on the most common operating systems. Its free software license and therefore the availability of all source code to the user, makes it an excellent research tool, as it allows all results to be completely reproducible. Looking at papers like <span class="citation">Baker (<a href="#ref-baker20161">2016</a>)</span>, that focus on problems with the reproducibility of other scientists’ experiments, the necessity of such scientific practices becomes apparent.</p>
</div>
<div id="nomenclature-of-routing-results" class="section level2">
<h2 class="hasAnchor">
<a href="#nomenclature-of-routing-results" class="anchor"></a>Nomenclature of routing results</h2>
<p>“<strong>path</strong> <code>noun | \ˈpath, ˈpäth\</code> […] a sequence of arcs in a network that can be traced continuously without retracing any arc”<br><span class="citation">Merriam-Webster.com (<a href="#ref-mwPath">2017</a><a href="#ref-mwPath">a</a>)</span></p>
<p>“<strong>route</strong> <code>noun | \ˈrüt, ˈrau̇t\</code> […] an established or selected course of travel or action”<br><span class="citation">Merriam-Webster.com (<a href="#ref-mwRoute">2017</a><a href="#ref-mwRoute">b</a>)</span></p>
<p>Usually, the results produced by routing software like implementations of Dijkstra’s algorithm as described in <span class="citation">Dijkstra (<a href="#ref-dijkstra1959note">1959</a>)</span> are least-cost edge sequences called paths or routes. An overview about routing algorithms can be found in <span class="citation">Hall (<a href="#ref-hall2012handbook">2012</a>)</span>. And whilst some of these rely on probabilities in order to simulate realistic route choice behaviour, the eventual routing results are still paths. Implementations of the Cross-Nested Logit, Probit and the Logit Kernel model can be found in <span class="citation">Ben-Akiva, Ramming, and Bekhor (<a href="#ref-ben2004route">2004</a>)</span>. It is important to clarify that the routing results produced by <code>osmprob</code> are not paths, but a set of traversal probabilities of all edges on the graph and other values derived from that. For lack of more fitting terminology, they will be referred to as routing results in this paper.</p>
</div>
<div id="road-data" class="section level2">
<h2 class="hasAnchor">
<a href="#road-data" class="anchor"></a>Road data</h2>
<p>The road data used in this package is taken from the OpenStreetMap project, a platform that provides open geodata on a global scale. It is maintained by the <span class="citation">OpenStreetMap contributors (<a href="#ref-OpenStreetMap">2017</a>)</span>. The data is downloaded using the <code>osmdata</code> package, which acts as an efficient handler for the Overpass API<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> and conveniently downloads and formats OpenStreetMap data and can therefore be seamlessly integrated in the routing workflow. The package is authored and maintained by <span class="citation">Padgham (<a href="#ref-osmdata">2017</a>)</span>.</p>
</div>
</div>
<div id="methods" class="section level1">
<h1 class="hasAnchor">
<a href="#methods" class="anchor"></a>Methods</h1>
<p>The methods used in this paper include several steps of data preprocessing and finally the routing functionality. As this paper focuses on more the <code>osmprob</code> package as a whole and not on the routing methodology itself, an in-depth discussion of <span class="citation">Saerens et al. (<a href="#ref-saerens2009randomized">2009</a>)</span> is omitted at this point.</p>
<div id="preprocessing" class="section level2">
<h2 class="hasAnchor">
<a href="#preprocessing" class="anchor"></a>Preprocessing</h2>
<p>The OpenStreetMap road data can not be used in its raw form by <code>osmprob</code>, but has to be preprocessed first in order to produce robust results and to minimise calculation time. According to <span class="citation">Dasu and Johnson (<a href="#ref-dasu2003exploratory">2003</a>)</span>, data preprocessing in data analysis takes up 80% of the time, which shows that it is worthwhile to invest in the development of a robust and efficient means of data preprocessing. For this reason, <code>osmprob</code> features a completely automated preprocessing routine, that allows users to input coordinates of a desired region and have the entire download and data cleaning process run in one go. The computationally expensive parts of this process were implemented in C++ using the <code>Rcpp</code> package, which brings large improvements in performance, as has been shown by <span class="citation">Eddelbuettel and François (<a href="#ref-rcpp2011">2011</a>)</span>. The preprocessing process includes three steps:</p>
<ul>
<li>Identifying and isolating the largest connected component in the graph</li>
<li>Removing vertices that are not needed to preserve the graph’s topology</li>
<li>Mapping the edges of the processed graph back on to the original graph</li>
</ul>
<p>As there was no software available that performs these steps reliably and highly performant, they had to be implemented as a part this package. The following sections illustrate the details of each preprocessing step.</p>
<div id="identifying-largest-graph-component" class="section level3">
<h3 class="hasAnchor">
<a href="#identifying-largest-graph-component" class="anchor"></a>Identifying largest graph component</h3>
<p>Graph based routing algorithms do not work on a disconnected graph. But when downloading subsets of OpenStreetMap data based on a bounding box, the resulting graph may consist of several disconnected smaller graphs or components, as illustrated by the different colours for the vertices showed in figure 1. In this example, the graph consists of four components, so three of them are going to be removed in this process. One way to obtain a single connected component, is to number all separate connected components inside a bounding box individually, then pick the one component best suitable for the routing process and delete all others. In this package, the selection is based on the number of vertices in the component, which is practical for most routing applications.</p>
<div class="figure" style="text-align: center">
<img src="osmprob_files/figure-html/unnamed-chunk-2-1.svg" alt="Figure 1: Original data, consisting of different graph components" width="672"><p class="caption">
Figure 1: Original data, consisting of different graph components
</p>
</div>
<p>The following sample of pseudocode illustrates how the largest graph component is identified.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    component_number =<span class="st"> </span><span class="dv">0</span>

    <span class="co"># initially, set all component numbers to -1 (invalid)</span>
    for vertex in all_vertices
        <span class="kw">comp_num.at</span> (vertex) =<span class="st"> </span>-<span class="dv">1</span>

    for vertex in all_vertices
        set component_numbers <span class="co"># initialise empty set of component numbers</span>

        <span class="co"># insert component numbers of current and all neighbouring vertices</span>
        <span class="kw">component_numbers.insert</span> (<span class="kw">comp_num.at</span> (vertex))
        for neighbour in <span class="kw">vertex.get_neighbours</span> ()
            <span class="kw">component_numbers.insert</span> (neighbour)

        <span class="co"># identify biggest component number of current neighbourhood</span>
        largest =<span class="st"> </span><span class="kw">max</span> (component_numbers)

        <span class="co"># component number is -1, so this neighbourhood is not in the list yet</span>
        if largest ==<span class="st"> </span>-<span class="dv">1</span>
            largest =<span class="st"> </span>component_number
            component_number++

<span class="st">        </span><span class="co"># assign largest component number to current vertex and its neighbours</span>
<span class="st">        </span><span class="kw">comp_num.at</span> (vertex) =<span class="st"> </span>largest
        for neighbour in <span class="kw">vertex.get_neighbours</span> ()
            <span class="kw">comp_num.at</span> (neighbour) =<span class="st"> </span>largest

        <span class="co"># every vertex with a component number listed in component_numbers gets</span>
        <span class="co"># the largest component number, thus combining previously disconnected</span>
        <span class="co"># components</span>
        for cn in comp_num
            if (<span class="kw">component_numbers.contains</span> (cn) &amp;&amp;<span class="st"> </span>cn.component_number !=<span class="st"> </span>-<span class="dv">1</span>
                <span class="kw">comp_num.at</span> (cn) =<span class="st"> </span>largest

    <span class="co"># remove remaining vertices</span>
    for com in comp_num
        if com !=<span class="st"> </span>largest
            <span class="kw">allVertices.erase</span> (com)</code></pre></div>
<p>At this point every node in the graph has been assigned a component number. Nodes sharing the same component number are necessarily part of one connected unit and are disjoint from any nodes with different component numbers. Therefore, the component number with the highest frequency c<sub>max</sub> is indicative of the largest connected component. Now all nodes with component number != c<sub>max</sub> can be stripped off the original graph, which results in exactly one connected graph.</p>
<div class="figure" style="text-align: center">
<img src="osmprob_files/figure-html/unnamed-chunk-4-1.svg" alt="Figure 2: Identifying largest component" width="672"><p class="caption">
Figure 2: Identifying largest component
</p>
</div>
</div>
<div id="removing-intermediate-nodes" class="section level3">
<h3 class="hasAnchor">
<a href="#removing-intermediate-nodes" class="anchor"></a>Removing intermediate nodes</h3>
<p>All nodes that are not necessary for routing are removed from the graph. This means that nodes that only have two neighbours and are connected to both of them either by one-way streets or two-way streets can be removed and the original edges replaced with new ones connecting the remaining vertices. This constraint is illustrated in figure 3. Node <code>B</code> can be removed in graph 1) and 2), but not in 3). Applying it to the preprocessing routine ensures that all topological information of the original graph is preserved.</p>
<div class="figure" style="text-align: center">
<img src="osmprob_files/figure-html/unnamed-chunk-5-1.svg" alt="Figure 3: Intermediate nodes in one-way, two-way and mixed streets" width="672"><p class="caption">
Figure 3: Intermediate nodes in one-way, two-way and mixed streets
</p>
</div>
<p>Applying these rules to the input graph removes all unnecessary intermediate vertices, leaving only the vertices that will be part of the final compact graph.</p>
<div class="figure" style="text-align: center">
<img src="osmprob_files/figure-html/unnamed-chunk-6-1.svg" alt="Figure 4: Removing intermediate nodes" width="672"><p class="caption">
Figure 4: Removing intermediate nodes
</p>
</div>
</div>
<div id="inserting-replaced-edges" class="section level3">
<h3 class="hasAnchor">
<a href="#inserting-replaced-edges" class="anchor"></a>Inserting replaced edges</h3>
<p>Removing vertices from a graph implies removing edges. In order to preserve the original graph’s topology, all edges are replaced with topologically equivalent direct edges between the remaining vertices. And even though this can lead to more edges leading to and from vertices, all edges keep their distinct IDs and can at any point be mapped back on the original graph. This way, the routing can be performed on the compact graph, whilst using the original graph’s edge weights for the calculations and later on its geographical features for visualisation. The following piece of pseudocode illustrates how vertices and edges to be removed are identified, replaced with new edges that have appropriate attributes and finally how these changes in the graph are tracked in a map of new and replaced edge IDs in order to be able to trace back what parts of the original graph are represented by their compact counterparts.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="co"># initialise unique edge ID of replacement edge</span>
    new_edge_id =<span class="st"> </span><span class="kw">max</span> (<span class="kw">all_edges.get_ids</span> ()) +<span class="st"> </span><span class="dv">1</span>

    <span class="co"># initialise map with replacement edge ID as key and a set of edge IDs as</span>
    <span class="co"># value</span>
    replacements =<span class="st"> </span><span class="kw">map</span> (replacement_id, edge_id [])

    for vertex in all_vertices

        <span class="co"># if a vertex has exactly two neighbouring vertices, it can be replaced</span>
        if (<span class="kw">vertex.num_neighbours</span> () ==<span class="st"> </span><span class="dv">2</span>)

            <span class="co"># initialise values for replacement edge</span>
            new_edge_weight =<span class="st"> </span><span class="dv">0</span>
            new_edge_start
            new_edge_end
            <span class="co"># initialise counter for number of edges to be replaced</span>
            edges_replaced =<span class="st"> </span><span class="dv">0</span>

            for edge in all_edges
                <span class="co"># if current vertex is part of the current edge, replace edge</span>
                if (<span class="kw">edge.get_start</span> () ==<span class="st"> </span>vertex ||<span class="st"> </span><span class="kw">edge.get_end</span> () ==<span class="st"> </span>vertex)

                    <span class="co"># depending on which of the two edges linked to the current</span>
                    <span class="co"># vertex is selected, set new edge parameters and update</span>
                    <span class="co"># neighbours of the neighbouring vertices</span>
                    if (<span class="kw">edge.get_start</span> () ==<span class="st"> </span>vertex)
                        <span class="kw">new_edge_end</span> () =<span class="st"> </span><span class="kw">edge.get_end</span> ()
                        neighbour_1 =<span class="st"> </span><span class="kw">vertex.get_neighbour_from</span> ()
                        <span class="kw">neighbour_1.set_neighbour_to</span> (<span class="kw">edge.get_end</span> ())
                    if (<span class="kw">edge.get_end</span> () ==<span class="st"> </span>vertex)
                        new_edge_start =<span class="st"> </span><span class="kw">edge.get_start</span> ()
                        neighbour_2 =<span class="st"> </span><span class="kw">vertex.get_neighbour_to</span> ()
                        <span class="kw">neighbour_2.set_neighbour_to</span> (<span class="kw">edge.get_start</span> ())

                    <span class="co"># update new edge parameters</span>
                    new_edge_weight +<span class="er">=</span><span class="st"> </span><span class="kw">edge.get_weight</span> ()

                    <span class="co"># update map of replaced edge IDs</span>
                    edges_rep =<span class="st"> </span><span class="kw">replacements.get</span> (new_edge_id)
                    <span class="kw">edges_rep.insert</span> (<span class="kw">edge.get_id</span> ())
                    <span class="kw">replacements.set</span> (new_edge_id)

                    <span class="co"># remove edge and increment edge counter </span>
                    <span class="kw">edge.remove</span> ()
                    edges_replaced ++

<span class="st">                    </span><span class="co"># if both edges are found and removed, insert new one and</span>
<span class="st">                    </span><span class="co"># remove current vertex</span>
<span class="st">                    </span>if (edges_replaced ==<span class="st"> </span><span class="dv">2</span>)
                        replacement =<span class="st"> </span><span class="kw">edge</span> (new_edge_start, new_edge_end,
                                            new_edge_weight, new_edge_id)
                        <span class="kw">edges.insert_edge</span> (replacement)
                        <span class="kw">vertex.remove</span> ()
                        new_edge_id ++<span class="st"> </span><span class="co"># increment new edge ID for next edge</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="osmprob_files/figure-html/unnamed-chunk-8-1.svg" alt="Figure 5: Inserting edges between remaining nodes" width="672"><p class="caption">
Figure 5: Inserting edges between remaining nodes
</p>
</div>
<p>Figure 6 shows a real world example of the principles outlined above. The original graph displayed in blue is replaced by the red compact graph that only contains the nodes necessary to maintain the original topology. The small disjoint part of the original graph has been removed, as it is not accessible from the main graph and can therefore not be used in the routing process.</p>
<div class="figure">
<img src="graph_orig_compact.png" alt="Figure 6: Comparison between compact and original graph on street data"><p class="caption">Figure 6: Comparison between compact and original graph on street data</p>
</div>
</div>
</div>
<div id="routing" class="section level2">
<h2 class="hasAnchor">
<a href="#routing" class="anchor"></a>Routing</h2>
<p>After the preprocessing is done, the graph can be used for routing purposes. The routing function is an implementation of the methods proposed in <span class="citation">Saerens et al. (<a href="#ref-saerens2009randomized">2009</a>)</span>. It calculates for each edge in the graph the probability of it being traversed on the way from a starting to an end point based on two factors. One is the edge weight, which in <code>osmprob</code> is a function of the geographic distance and the road type. The second one is a nondimensional value that <span class="citation">Saerens et al. (<a href="#ref-saerens2009randomized">2009</a>)</span> refer to as <span class="math inline">\(\eta\)</span>. Its value is used to quantify the global entropy that the routing algorithm uses in that for <span class="math inline">\(\eta\)</span> approximating 0, the global entropy rises. Part of this paper is to understand the influence that different <span class="math inline">\(\eta\)</span> have on the calculation times and routing results and how to tune <span class="math inline">\(\eta\)</span> in a way that it leads to good routing results. Using these methods for routing leads to a probabilistic rather than deterministic routing result, which is why this routing method is fundamentally different to the ones mentioned in the introduction.</p>
</div>
</div>
<div id="installation" class="section level1">
<h1 class="hasAnchor">
<a href="#installation" class="anchor"></a>Installation</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">install</span> (<span class="st">"osm-router/osmprob"</span>)</code></pre></div>
</div>
<div id="usage" class="section level1">
<h1 class="hasAnchor">
<a href="#usage" class="anchor"></a>Usage</h1>
<p>The only input needed to download street data are the coordinates of the start and end points on the graph. The <code>download_graph</code> function builds a bounding box including an optional buffer around the points and downloads all OpenStreetMap data tagged as <code>key = highway</code><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> in it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start_pt &lt;-<span class="st"> </span><span class="kw">c</span> (<span class="fl">10.5350035429</span>,<span class="fl">47.6034937672</span>)
end_pt &lt;-<span class="st"> </span><span class="kw">c</span> (<span class="fl">10.5384796858</span>,<span class="fl">47.6071612749</span>)
graph &lt;-<span class="st"> </span><span class="kw"><a href="../reference/download_graph.html">download_graph</a></span> (start_pt, end_pt)</code></pre></div>
<p>The function <code>select_vertices_by_coordinates</code> then identifies the vertices on the graph that lie closest to the desired start and end points. These are the points based on which the routing process will be performed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pts &lt;-<span class="st"> </span><span class="kw"><a href="../reference/select_vertices_by_coordinates.html">select_vertices_by_coordinates</a></span> (graph, start_pt, end_pt)
route_start &lt;-<span class="st"> </span>pts[<span class="dv">1</span>]
route_end &lt;-<span class="st"> </span>pts [<span class="dv">2</span>]</code></pre></div>
<p>At the moment, there are two routing algorithms implemented in this package and accessible by using <code>get_shortest_path</code> and <code>get_probability</code>, respectively. For the sake of consistency, the object returned by both functions is a <code>list</code> containing a <code>data.frame</code> with all relevant edges as a first item and the calculated distance as a second item. <code>get_shortest_path</code> returns the shortest path as calculated using an implementation of Dijkstra’s algorithm. The call <code>path$d</code> in the following example is used to access the path’s calculated distance in km.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">path &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_shortest_path.html">get_shortest_path</a></span> (graph, route_start, route_end)
path$d <span class="co"># 0.1427</span></code></pre></div>
<p><code>get_probability</code> calculates the traversal probability for the entire input graph. It returns the entire input graph with additional columns containing the global and local traversal probability for each edge. Like <code>get_shortest_path</code>, it returns a <code>list</code> object. The first entry is a <code>data.frame</code> with all edge, to which have been added two additional columns. They contain the routing probabilities for all edges in two different formats:</p>
<ul>
<li>
<code>prob</code>: The local routing probabilities from every vertex to all its neighbouring vertices. These values are the ones originally calculated in the routing algorithm. The probability densities and expected mean travel distance is derived from them. Because all values of <code>prob</code> add up to 1 on a local scale, they are hard to interpret on a global scale. This is why it is also necessary to calculate the global routing probabilities.</li>
<li>
<code>dens</code>: The global routing probabilities or routing densities. These values are derived from <code>prob</code> and indicate how likely an edge on the graph will be traversed on the way from start to end. As these values are easier to interpret than <code>prob</code>, they are used for graph visualisation.</li>
</ul>
<p>The second item in the returned list is the expected travel distance which is based on the calculated traversal probabilities. Its minimal possible value is the length of the shortest path and gets higher with increased global entropy, which can be done using lower values for <span class="math inline">\(\eta\)</span> (<code>eta</code>). Note that the distance rises very abrupt for <span class="math inline">\(\eta\)</span> approximating 0. The results section contains more information about the effects of <span class="math inline">\(\eta\)</span> on the routing results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_probability.html">get_probability</a></span> (graph, route_start, route_end, <span class="dt">eta =</span> <span class="fl">0.9</span>)
prob$d <span class="co"># 0.1934</span>
prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_probability.html">get_probability</a></span> (graph, route_start, route_end, <span class="dt">eta =</span> <span class="fl">0.7</span>)
prob$d <span class="co"># 0.2001</span>
prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_probability.html">get_probability</a></span> (graph, route_start, route_end, <span class="dt">eta =</span> <span class="fl">0.3</span>)
prob$d <span class="co"># 0.2418</span>
prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/get_probability.html">get_probability</a></span> (graph, route_start, route_end, <span class="dt">eta =</span> <span class="fl">0.01</span>)
prob$d <span class="co"># 1.3040</span></code></pre></div>
<p>Finally, the routing results can be visualised with the <strong>shiny</strong> <strong>leaflet</strong> mapping function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot_map.html">plot_map</a></span> (prob, path)</code></pre></div>
</div>
<div id="results" class="section level1">
<h1 class="hasAnchor">
<a href="#results" class="anchor"></a>Results</h1>
<p>The following section discusses the results achieved using <code>osmprob</code>. It also evaluates performance analysis from real world use cases and further shows the influence that different <span class="math inline">\(\eta\)</span> have on such statistics. The tests were run on 18 different randomly selected test regions. To reduce the chance of faulty outliers, the results of all speed measurements given are the median time of runs.</p>
<div id="routing-probabilities" class="section level2">
<h2 class="hasAnchor">
<a href="#routing-probabilities" class="anchor"></a>Routing probabilities</h2>
<p>Figure 7 shows the probabilistic routing results on a road graph and shows very clearly the influence that different <span class="math inline">\(\eta\)</span> have on the results. The red line on the graph indicates the shortest path between a start and end point. The line thickness on the green lines indicates the traversal probability on each edge on the way between the same two points. As discussed above, high <span class="math inline">\(\eta\)</span> mean a low global entropy and vice versa. Low global entropy means that the proposed edge traversal probabilities are higher when they are close to the ideal path. On the map this almost looks like the traversal probabilities resembling the shortest path. Only very close alternative routes that don’t necessitate large detours also have elevated probabilities. On the other hand, low <span class="math inline">\(\eta\)</span> lead to the probabilities “seeping away” from the ideal path. This can be observed by looking at the edges that are quite thin for high <span class="math inline">\(\eta\)</span>, but constantly become thicker with smaller <span class="math inline">\(\eta\)</span>, which is consistent with the initial expectations This effect also implies that the edges with higher probabilities for large <span class="math inline">\(\eta\)</span> will decrease in probability as the others around it will increase.</p>
<div class="figure">
<img src="eta.gif" alt="Figure 7: Varying probabilities for different global entropy parameters"><p class="caption">Figure 7: Varying probabilities for different global entropy parameters</p>
</div>
<p>Figure 8 shows the effects caused by different <span class="math inline">\(\eta\)</span> on the routing results described above on a numeric scale. Each line represents one pair of start and end points on a graph. The coloured dots sitting on that line indicate the value of <span class="math inline">\(\eta\)</span> used for the calculation. As stated above, high global entropy means that more edges of a graph are likely to being traversed, thereby increasing the expected mean distance of the trips. The rampant increase in expected distance also indicates that for low <span class="math inline">\(\eta\)</span>, slight changes have quite a big effect. This may even lead to estimated mean distances bigger than the sum of all edge lengths present in the graph, which is possible because random movement on the graph does not restrict the number of times a given edge can be traversed.</p>
<div class="figure">
<img src="osmprob_files/figure-html/unnamed-chunk-15-1.png" alt="Figure 8: Mean distances for different values of global entropy" width="672"><p class="caption">
Figure 8: Mean distances for different values of global entropy
</p>
</div>
</div>
<div id="speed" class="section level2">
<h2 class="hasAnchor">
<a href="#speed" class="anchor"></a>Speed</h2>
<p>Figures 9 and 10 show how the calculation time is affected by the graph size and the network distance between start and end point. They also give an indication of the performance difference between probabilistic routing and classic shortest path solutions at the example of Dijkstra’s algorithm. The graphs also indicate that different values for <span class="math inline">\(\eta\)</span> may also have an influence on calculation time. Specifically, low <span class="math inline">\(\eta\)</span> and thus high global entropies appear to be leading to longer calculation times. There are two negative outliers in the probabilistic routing calculation times. As they both occurred on graphs with very few vertices, these values show how big the influence of graph complexity on routing calculation time is.</p>
<div class="figure">
<img src="osmprob_files/figure-html/unnamed-chunk-16-1.png" alt="Figure 9: Calculation times for different shortest path alternatives" width="672"><p class="caption">
Figure 9: Calculation times for different shortest path alternatives
</p>
</div>
<div class="figure">
<img src="osmprob_files/figure-html/unnamed-chunk-17-1.png" alt="Figure 10: Calculation times for different graph sizes" width="672"><p class="caption">
Figure 10: Calculation times for different graph sizes
</p>
</div>
</div>
<div id="comparison-with-shortest-path-solutions" class="section level2">
<h2 class="hasAnchor">
<a href="#comparison-with-shortest-path-solutions" class="anchor"></a>Comparison with shortest path solutions</h2>
<p>Figure 11 shows the calculated probabilistic distances for different <span class="math inline">\(\eta\)</span> in comparison with the shortest path distances. As expected, all probabilistic distances are longer than the shortest path. The graph also shows how sensitive <span class="math inline">\(\eta\)</span> becomes when approximating 0. Note that a change in <span class="math inline">\(\eta\)</span> from 0.003 to 0.001 leads to an estimated distance of almost twice the length. Another observation that can be made is that the probabilistic distances have high alter quite a lot from one another. Table 1 shows the standard deviations of the expected distances for different <span class="math inline">\(\eta\)</span>, which are very high in comparison with the standard deviation of the shortest paths (0.402). And like the distances, their standard deviations are very sensitive to <span class="math inline">\(\eta\)</span>. Another possible reason for the spikes in the probabilistic distances could be the number of vertices in the road graph, because a more complex road graph would allow more movement between a start and end point than a very simple one would. So on a very simple graph, all movement would be restricted on few edges, even with high <span class="math inline">\(\eta\)</span>.</p>
<table class="table">
<caption>Table 1: Variances in probabilistic distance</caption>
<thead><tr class="header">
<th align="right">eta</th>
<th align="right">Standard deviation [km]</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">0.001</td>
<td align="right">5.700</td>
</tr>
<tr class="even">
<td align="right">0.003</td>
<td align="right">2.738</td>
</tr>
<tr class="odd">
<td align="right">0.006</td>
<td align="right">1.778</td>
</tr>
<tr class="even">
<td align="right">0.010</td>
<td align="right">1.316</td>
</tr>
<tr class="odd">
<td align="right">0.020</td>
<td align="right">0.897</td>
</tr>
<tr class="even">
<td align="right">0.040</td>
<td align="right">0.640</td>
</tr>
<tr class="odd">
<td align="right">0.060</td>
<td align="right">0.542</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="osmprob_files/figure-html/unnamed-chunk-20-1.png" alt="Figure 11: Comparison of probabilistic and shortest path solutions: distance" width="672"><p class="caption">
Figure 11: Comparison of probabilistic and shortest path solutions: distance
</p>
</div>
<div class="figure">
<img src="osmprob_files/figure-html/unnamed-chunk-21-1.png" alt="Figure 12: Comparison of probabilistic and shortest path solutions: graph complexity" width="672"><p class="caption">
Figure 12: Comparison of probabilistic and shortest path solutions: graph complexity
</p>
</div>
</div>
<div id="limitations" class="section level2">
<h2 class="hasAnchor">
<a href="#limitations" class="anchor"></a>Limitations</h2>
<p>In some test regions it was not possible to calculate probabilistic routes due to unexpected behaviour of <code>osmprob</code>. This includes program crashes, as well as the generation of unreasonably high values of estimated travel distances. The reasons leading these effects are yet to be identified. One possible explanation could be that under certain circumstances the software is attempting to perform routing on ill-formed graphs. This may happen when a graph is complete, but certain vertices are inaccessible due to directed edges leading only away from and not towards them. Another issue is the size of <span class="math inline">\(\eta\)</span> in the routing process. Because there is no way yet to scale <span class="math inline">\(\eta\)</span> properly, the routing results may be unrealistic in some cases and have to be used with caution.</p>
</div>
</div>
<div id="discussion-and-outlook" class="section level1">
<h1 class="hasAnchor">
<a href="#discussion-and-outlook" class="anchor"></a>Discussion and outlook</h1>
<p>The results show that <code>osmprob</code> can be used to adequately perform probabilistic routing tasks. The resulting traversal probabilities appear to represent realistic movement patterns for their respective <span class="math inline">\(\eta\)</span>. A reliable way to dimension <span class="math inline">\(\eta\)</span> for satisfactory results, however, is yet to be found. A possible solution for this issue could be to compare real world movement data with calculated results for different <span class="math inline">\(\eta\)</span> and investigate, which <span class="math inline">\(\eta\)</span> leads to results best representing the data.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-baker20161">
<p>Baker, Monya. 2016. “1,500 Scientists Lift the Lid on Reproducibility.” <em>Nature</em> 533 (7604): 452–54.</p>
</div>
<div id="ref-ben2004route">
<p>Ben-Akiva, Moshe E, M Scott Ramming, and Shlomo Bekhor. 2004. “Route Choice Models.” In <em>Human Behaviour and Traffic Networks</em>, 23–45. Springer.</p>
</div>
<div id="ref-dasu2003exploratory">
<p>Dasu, Tamraparni, and Theodore Johnson. 2003. <em>Exploratory Data Mining and Data Cleaning</em>. Vol. 479. John Wiley &amp; Sons.</p>
</div>
<div id="ref-dijkstra1959note">
<p>Dijkstra, Edsger W. 1959. “A Note on Two Problems in Connexion with Graphs.” <em>Numerische Mathematik</em> 1 (1). Springer: 269–71.</p>
</div>
<div id="ref-rcpp2011">
<p>Eddelbuettel, Dirk, and Romain François. 2011. “Rcpp: Seamless R and C++ Integration.” <em>Journal of Statistical Software</em> 40 (8): 1–18. <a href="http://www.jstatsoft.org/v40/i08/" class="uri">http://www.jstatsoft.org/v40/i08/</a>.</p>
</div>
<div id="ref-hall2012handbook">
<p>Hall, Randolph. 2012. <em>Handbook of Transportation Science</em>. Vol. 23. Springer Science &amp; Business Media.</p>
</div>
<div id="ref-mwPath">
<p>Merriam-Webster.com. 2017a. “Path.” <a href="https://www.merriam-webster.com/dictionary/path" class="uri">https://www.merriam-webster.com/dictionary/path</a>.</p>
</div>
<div id="ref-mwRoute">
<p>———. 2017b. “Route.” <a href="https://www.merriam-webster.com/dictionary/route" class="uri">https://www.merriam-webster.com/dictionary/route</a>.</p>
</div>
<div id="ref-OpenStreetMap">
<p>OpenStreetMap contributors. 2017. “Planet dump retrieved from https://planet.osm.org.” <a href="https://www.openstreetmap.org%20">https://www.openstreetmap.org</a>.</p>
</div>
<div id="ref-osmdata">
<p>Padgham, Mark. 2017. <em>Osmdata: Import Openstreetmap Data as Simple Features or Spatial Objects</em>. <a href="https://cran.r-project.org/package=osmdata" class="uri">https://cran.r-project.org/package=osmdata</a>.</p>
</div>
<div id="ref-saerens2009randomized">
<p>Saerens, Marco, Youssef Achbany, François Fouss, and Luh Yen. 2009. “Randomized Shortest-Path Problems: Two Related Models.” <em>Neural Computation</em> 21 (8). MIT Press: 2363–2404.</p>
</div>
<div id="ref-wickham2015r">
<p>Wickham, Hadley. 2015. <em>R Packages: Organize, Test, Document, and Share Your Code</em>. “ O’Reilly Media, Inc.”</p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://www.routino.org/xml/routino-profiles.xml" class="uri">https://www.routino.org/xml/routino-profiles.xml</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://www.r-project.org/" class="uri">https://www.r-project.org/</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://wiki.openstreetmap.org/wiki/Overpass_API" class="uri">http://wiki.openstreetmap.org/wiki/Overpass_API</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="http://wiki.openstreetmap.org/wiki/Key:highway" class="uri">http://wiki.openstreetmap.org/wiki/Key:highway</a><a href="#fnref5">↩</a></p></li>
</ol>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#introduction">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#r-packages"><em>R</em> packages</a></li>
      <li><a href="#nomenclature-of-routing-results">Nomenclature of routing results</a></li>
      <li><a href="#road-data">Road data</a></li>
      </ul>
</li>
      <li>
<a href="#methods">Methods</a><ul class="nav nav-pills nav-stacked">
<li><a href="#preprocessing">Preprocessing</a></li>
      <li><a href="#routing">Routing</a></li>
      </ul>
</li>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#usage">Usage</a></li>
      <li>
<a href="#results">Results</a><ul class="nav nav-pills nav-stacked">
<li><a href="#routing-probabilities">Routing probabilities</a></li>
      <li><a href="#speed">Speed</a></li>
      <li><a href="#comparison-with-shortest-path-solutions">Comparison with shortest path solutions</a></li>
      <li><a href="#limitations">Limitations</a></li>
      </ul>
</li>
      <li><a href="#discussion-and-outlook">Discussion and outlook</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Andreas Petutschnig, Mark Padgham.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
