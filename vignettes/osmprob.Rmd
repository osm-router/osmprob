---
title: "Introduction to osmprob"
author: "Andreas Petutschnig"
date: "`r Sys.Date()`"
output:
    html_document:
        toc: true
        toc_depth: 2
        number_sections: true
        theme: journal
header-includes: 
    - \usepackage{tikz}
link-citations: true

abstract: "When using routing algorithms to model movement on a graph, one is
not necessarily interested in obtaining the least-cost, but the most realistic
results. The average path between any two points is likely never the shortest,
yet there is currently no way to estimate the course or lengths of realistic
paths. Instead, movement is often assumed to be singular and repeatable.
**osmprob** is an *R* library that provides routing probabilities along all
possible paths between any two points.  The path of highest probability is the
shortest, yet all edges will generally have non-zero probabilities of being
traversed.  Importantly, the resultant network enables calculation of the
probabalistically most likely distance travelled between any two points. The
package comes with a built-in **Shiny** **Leaflet** application to display the
results in a matter that is both understandable and visually pleasing."

keywords: routing, planning, OpenStreetMap

vignette: >
  %\VignetteIndexEntry{osmprob}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: osmprob-refs.bib
---

```{r echo=FALSE}
library (magrittr)
dat <- read.csv2 ("benchmark_osmprob.csv", stringsAsFactors = FALSE)
dat$t_shortest %<>% as.numeric
dat$t_prob %<>% as.numeric
dat$dl_time %<>% as.numeric
dat$d_shortest %<>% as.numeric
dat$d_prob %<>% as.numeric
```

# Introduction

`osmprob` is an R package that allows users to calculate traversal probabilities
and the estimated travel distance between two points on a graph based on the
methods introduced in @saerens2009randomized. It also contains methods that
simplify the process of downloading and preprocessing road data on which the
routing can be performed. This step also includes weighting the edges according
to a specified means of transport. The values used for weighting are derived
from the Routino weighting profiles[^1]. Finally, the results can be visualised
with built-in mapping functions.

## R packages

R is a programming language that is maintained by the R Foundation for
Statistical Computing[^2] and is freely available under the GNU General Public
License. R uses packages, which allow users to access additional functionality.
These packages are written and maintained by numerous contributors and can be
accessed via the Comprehensive R Archive Network (CRAN)[^3]. The packages are
built according to a specific structure, which is explained in @wickham2015r.
This software was also built in form of a package. One reason why this format of
software was chosen was because of its interoperability. R is platform
independent an can therefore be used on the most common operating systems. Its
free software license and therefore the availability of all source code to the
user, makes it an excellent research tool, as it allows all results to be
completely reproducible. Looking at papers like @baker20161, that focus on
problems with the reproducibility of other scientists' experiments, the
necessity of such scientific practices becomes apparent.

## Nomenclature

"**path** `noun | \ˈpath, ˈpäth\` [...] a sequence of arcs in a network that can
be traced continuously without retracing any arc"  
@mwPath

"**route** `noun | \ˈrüt, ˈrau̇t\` [...] an established or selected course of
travel or action"  
@mwRoute

Usually, the results produced by routing software like implementations of
Dijkstra's algorithm (@dijkstra1959note) are least-cost edge sequences called
paths or routes. An overview about routing algorithms can be found in
@hall2012handbook. And while some of these rely on probabilities in order to
simulate realistic route choice behaviour, the eventual routing results are
still paths. Implementations of the Cross-Nested Logit, Probit and the Logit
Kernel model can be found in @ben2004route. It is important to clarify that the
routing results produced by this software are not paths, but a set of traversal
probabilities of all edges on the graph. For lack of more fitting terminology,
they will be referred to as routes in this paper.

## Road data

The road data used in this package is taken from the OpenStreetMap project,
a platform that provides open geodata on a global scale. It is maintained by the
@OpenStreetMap. The data is downloaded using the `osmdata` package, which is
maintained by @osmdata.

# Methods

The methods used in this paper include several steps of data preprocessing and
finally the routing functionality. As this paper focuses on more the `osmprob`
package as a whole and not on the routing methodology itself, an in-depth
discussion of @saerens2009randomized is omitted at this point.

## Preprocessing

The OpenStreetMap road data can not be used in its raw form by `osmprob`, but
has to be preprocessed first in order to produce robust results and to lower
calculation time. @dasu2003exploratory claim that data preprocessing in data
analysis takes up 80% of the time. This makes a robust and efficient
preprocessing routine necessary. For this reason, `osmprob` features a
completely automated preprocessing routine, that allows users to input
coordinates of a desired region and have the entire download and data cleaning
process run in the background.  The computationally expensive parts of this
process were implemented in C++ using the `Rcpp` package, which brings large
improvements in performance @rcpp2011. The preprocessing includes three steps:

- Identifying and isolating the largest connected component in the graph
- Removing vertices that are not needed to preserve the graph's topology
- Mapping the edges of the processed graph back on to the original graph

The following sections illustrate the methods used for preprocessing.

### Identifying largest graph component

Graph based routing algorithms do not work on a disconnected graph. But when
downloading subsets of OpenStreetMap data based on a bounding box, the resulting
graph may consist of several disconnected components, as figure 1 illustrates.
One way to obtain a single connected component, is to identify all separate
connected components inside a bounding box, then select one and delete all
others. In this package, the selection is based on the number of vertices in the
component, which is practical for most routing applications.

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("graph_pp1.tex"), fig.cap="Figure 1: Original data, consisting of different graph components"}
```

The following sample of pseudocode illustrates how the largest graph component
is identified.

<!-- todo: clarify: component, compact graph, neighbours, write out
pseudocode -->

```{r eval=FALSE}
    component_number = 0

    # initially, set all component numbers to -1 (invalid)
    for vertex in all_vertices
        comp_num.at (vertex) = -1

    for vertex in all_vertices
        set component_numbers # initialize empty set of component numbers

        # insert component numbers of current and all neighbouring vertices
        component_numbers.insert (comp_num.at (vertex))
        for neighbour in vertex.get_neighbours ()
            component_numbers.insert (neighbour)

        # identify biggest component number of current neighbourhood
        largest = max (component_numbers)

        # component number is -1, so this neighbourhood is not in the list yet
        if largest == -1
            largest = component_number
            component_number++

        # assign largest component number to current vertex and its neighbours
        comp_num.at (vertex) = largest
        for neighbour in vertex.get_neighbours ()
            comp_num.at (neighbour) = largest

        # every vertex with a component number listed in component_numbers gets
        # the largest component number, thus combining previously disconnected
        # components
        for cn in comp_num
            if (component_numbers.contains (cn) && cn.component_number != -1
                comp_num.at (cn) = largest

    # remove remaining vertices
    for com in comp_num
        if com != largest
            allVertices.erase (com)
```

At this point every node in the graph has been assigned a component number.
Nodes sharing the same component number are necessarily part of one connected
unit and are disjoint from any nodes with different component numbers.
Therefore, the component number with the highest frequency c~max~ is indicative
of the largest connected component. Now all nodes with component number !=
c~max~ can be stripped off the original graph, which results in one connected
graph.

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("graph_pp2.tex"), fig.cap="Figure 2: Identifying largest component"}
```

### Removing intermediate nodes

All nodes that are not necessary for routing are removed from the graph. This
means that nodes that only have two neighbours and are connected to both of them
either by one-way streets or two-way streets can be removed and the original
edges replaced with new ones connecting the remaining vertices. This is
illustrated in figure 3. Node `B` can be removed in graph 1) and 2), but not in
3).

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("graph_rm_vertex.tex"), fig.cap="Figure 3: Intermediate nodes in one-way, two-way and mixed streets"}
```

Applying these rules to the input graph removes all unnecessary intermediate
vertices, leaving only the vertices that will be part of the final compact
graph.

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("graph_pp3.tex"), fig.cap="Figure 4: Removing intermediate nodes"}
```


### Inserting replaced edges

Removing vertices from a graph implies removing edges. In order to preserve the
original graph's topology, all edges are replaced with topologically equivalent
direct edges between the remaining vertices. While this can lead to more edges
leading to and from vertices, all edges keep their distinct ids and can at any
point be mapped back on the original graph. This way, the routing can be
performed on the compact graph, while using the original graph's edge weights
for the calculations and later on its geographical features for visualisation.


```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("graph_pp4.tex"), fig.cap="Figure 5: Inserting edges between remaining nodes"}
```

Figure 6 shows a real world example of the principles outlined above. The
original graph displayed in blue is replaced by the red compact graph that only
contains the nodes necessary to maintain the original topology. The small
disjoint part of the original graph is removed.

![Figure 6: Comparison between compact and original graph on street data](graph_orig_compact.png)

## Routing

The routing function is greatly influenced by a undefined value that
@saerens2009randomized refer to as $\eta$. Part of this paper is to understand
the influence that different $\eta$ have on the calculation times and routing
results.

# Usage

The only input needed to download street data are the coordinates of the start
and end points on the graph. The `download_graph` function builds a bounding box
including an optional buffer around the points and downloads all OpenStreetMap
data tagged as `key = highway`[^4] in it.

```{r eval=FALSE}
devtools::load_all (export_all = FALSE)
start_pt <- c (11.58, 48.14)
end_pt <- c (11.585, 48.145)
graph <- download_graph (start_pt, end_pt)
```

The function `select_vertices_by_coordinates` then identifies the vertices on
the graph that lie closest to the desired start and end points.  These are the
points based on which the routing process will be performed.

```{r eval=FALSE}
pts <- select_vertices_by_coordinates (graph, start_pt, end_pt)
route_start <- pts[1]
route_end <- pts [2]
```

At the moment, there are two routing algorithms implemented in this package.
`get_shortest_path` returns the shortest path as calculated using an
implementation of Dijkstra's algorithm.

```{r eval=FALSE}
path <- get_shortest_path (graph, route_start, route_end)
```

The `get_probability` function calculates the traversal probability for the
entire input graph. It returns the entire input graph with an additional column
containing the traversal probability for each edge.

```{r eval=FALSE}
prob <- get_probability (graph, route_start, route_end, eta = 1)
```

Finally, the routing results can be visualised in a **shiny** **leaflet** web
map.

```{r eval=FALSE}
plot_map (prob, path)
```

# Results

The following section discusses the results achieved using `osmprob`. It also
shows performance analysis from real world use cases and further shows the
influence of $\eta$ on such statistics.

## Routing probabilities

![Figure 7: Varying probabilities for different global entropy parameters](eta.gif)

## Speed

Figure 8 shows how the calculation time is affected by the graph size. It also
gives an indication of the large performance difference between probabilistic
routing and classic shortest path solutions at the example of Dijkstra's
algorithm. The graph also indicates that different values for $\eta$ also have an
influence on calculation time. Specifically, lower values for $\eta$ appear to be
leading to longer calculation times.

```{r echo=FALSE, fig.cap="Figure 8: Performance analysis of omsprob"}
ttl <- "Estimated mean distances for different values of global entropy"
xlab <- substitute (paste ("Global entropy [",eta, "]"))
legendlab <- substitute (paste ("Global entropy [", eta, "]"))

plt <- ggplot2::ggplot (data = dat) +
    ggplot2::geom_line (ggplot2::aes (x = eta, y = d_prob, group = region_num),
                        colour = "#ababab") +
    ggplot2::geom_point (ggplot2::aes (x = eta, y = d_prob,
                                       colour = factor (eta)), size = 2) +
    ggplot2::labs (title = ttl, x = xlab, y = "Distance [km]") +
    ggplot2::theme_bw (base_family = "TeX Gyre Bonum") +
    ggplot2::theme (plot.title = ggplot2::element_text(hjust = 0.5),
                    legend.box.background = ggplot2::element_rect ()) +
    ggplot2::scale_colour_discrete (name = legendlab)

plt
```

## Comparison with shortest path solutions

```{r echo=FALSE, fig.cap="Figure 9: Comparison of probabilistic and shortest path solutions"}
ttl <- "Distance differences between shortest and probabilistic routes"
legendlab <- substitute (paste ("Global entropy [", eta, "]"))

plt <- ggplot2::ggplot (data = dat) +
    ggplot2::geom_line (ggplot2::aes (x = d_shortest, y = d_prob,
                                      colour = factor (eta)), size = 1) +
    ggplot2::geom_line (ggplot2::aes (x = d_shortest, y = d_shortest,
                                      colour = "Shortest Path"), size = 1.5) +
    ggplot2::labs (title = ttl,
                   x = "Shortest Distance [km]",
                   y = "Probabilistic distance [km]") +
    ggplot2::theme_bw (base_family = "TeX Gyre Bonum") +
    ggplot2::theme (plot.title = ggplot2::element_text(hjust = 0.5),
                    legend.box.background = ggplot2::element_rect ()) +
    ggplot2::scale_colour_discrete (name = legendlab)

plt
```

## Scalability

```{r echo=FALSE, fig.cap="Figure 10: Scalability of probabilistic routing"}
num <- dim (dat) [1] / dat$region_num %>% unique %>% length

rbn_vals_mn <- vector (length = length (unique (dat$region_num)) * num,
                       mode = "numeric")
rbn_vals_mx <- vector (length = length (unique (dat$region_num)) * num,
                       mode = "numeric")

ct <- 1
for (i in unique (dat$region_num))
{
    rbn_vals_mn [ct:(ct + 6)] <- min (dat$t_prob [dat$region_num == i])
    rbn_vals_mx [ct:(ct + 6)] <- max (dat$t_prob [dat$region_num == i])
    ct <- ct + num
}

ttl <- "Calculation times for different graph sizes
and values of global entropy"
legendlab <- substitute (paste ("Global entropy [", eta, "]"))

plt <- ggplot2::ggplot (data = dat) +
    ggplot2::geom_ribbon (ggplot2::aes (x = n_vtx_comp, ymin = rbn_vals_mn,
                                        ymax = rbn_vals_mx),
                          fill = "#81A88D", alpha = 0.3) +
    ggplot2::geom_line (ggplot2::aes (x = n_vtx_comp, y = t_prob,
                                      colour = eta)) +
    ggplot2::geom_line (ggplot2::aes (x = n_vtx_comp, y = d_shortest,
                                      colour = "Shortest Path"), size = 1) +
    ggplot2::geom_point (ggplot2::aes (x = n_vtx_comp, y = dl_time),
                         shape = 4) +
    ggplot2::labs (title = ttl,
                   x = "Distance of shortest path [m]",
                   y = "Time (median of n = 30 runs) [ms]") +
    ggplot2::theme_bw (base_family = "TeX Gyre Bonum") +
    ggplot2::theme (plot.title = ggplot2::element_text(hjust = 0.5),
                    legend.box.background = ggplot2::element_rect ()) +
    ggplot2::scale_colour_discrete (name = legendlab)

plt
```

# Discussion and outlook

# References

[^1]: https://www.routino.org/xml/routino-profiles.xml
[^2]: https://www.r-project.org/
[^3]https://cran.r-project.org/
[^4]: http://wiki.openstreetmap.org/wiki/Key:highway
